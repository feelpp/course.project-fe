= Project: Solving a Partial Differential Equation by the Finite Element Method in a 2D Domain
Author: {student-name}
:toc:
:date: {current-date}
:cpp: C++

== A Joint Project Between C++ for Scientific Computing and Project Development and Management

This project is part of a collaborative effort between two courses: *C++ for Scientific Computing* and *Project Development and Management*. The aim is to provide students with a comprehensive learning experience combining advanced C++ programming techniques with essential software engineering and project management practices.

In the *C++ for Scientific Computing* component, students focus on implementing a finite element method (FEM) to solve a Poisson-type partial differential equation (PDE) in a 2D domain. This involves understanding the mathematical formulation of the problem, translating it into efficient C++ code, and using tools such as _Eigen_ and _Gmsh_ for linear algebra and mesh generation.

In the *Project Development and Management* course, students are introduced to modern development workflows, including version control with GitHub, CI/CD using GitHub Actions, unit testing, and Docker containerization.

== Introduction

The origins of the finite element method date back to the 1950s when engineers used it to simulate problems in continuous media mechanics. Over time, it has evolved into a robust simulation tool for problems in continuum mechanics, fluid mechanics, thermodynamics, electromagnetism, and finance.

In this project, we are interested in solving a Poisson-type PDE in a bounded domain Ω ⊆ ℝ². Many physical models fit this form, such as conductive heat transfer and electrostatics. The system to solve is:

[latexmath]
++++
-\Delta u = f \quad \text{in } \Omega, \quad u = g \quad \text{on } \Gamma
++++

where:

* stem:[f] is a function defined on stem:[\Omega]
* stem:[g] is a function defined on stem:[\Gamma]

The goal is to find a real-valued function stem:[u], stem:[u : \Omega \mapsto \mathbb{R}]. 

NOTE: Typically, no explicit solution exists, so we approximate the solution using the finite element method (FEM).


== C++ Project

== {cpp} Course Objectives: {cpp}, STL, Eigen, and CMake

The objectives of the project are to implement one or more C++ programs to handle the three parts described above.
The quality of the C++ code, the choice of data structures, the efficiency of the program, and the annotations used to make the code easier to understand will be evaluated.
The program(s) must be parameterizable, in the sense that results can be obtained according to parameters given by the user.
This will be done either from the command line or via a configuration file given to the executable (the second method is preferable).
It should be possible to test the objectives of each part using the documentation provided.

A project report is required. It will account for about half of the grade. It should provide a brief description of the project, defining the functionalities of the C++ program, the choice of data structures, the structure of the code, any mathematical or other details not provided, the tests carried out, and the commands used to reproduce the results.

As far as C++ programming is concerned, you are free to use any functionality of the STL or the _Eigen_ library. Any other external library will not be authorized.

=== Project Course Objectives: Version Control, CI/CD, and Docker
In addition to the scientific computing objectives of the project, this course includes essential software engineering practices related to modern development workflows. Students are expected to apply version control, continuous integration, testing, and containerization in their C++ projects. The following tasks are part of the project:

1. Version Control with GitHub:
All project development should take place in a GitHub repository. The following aspects are required:

* Repository setup: Create a public or private GitHub repository for your project.
* Branching: Use branches for different features or parts of the project. The main branch should always contain stable and functional code.
* Commits and Pull Requests: Follow best practices for commit messages and use pull requests (PRs) to merge changes into the main branch. PRs should be peer-reviewed by other students.
* Collaborative Development: If working in teams, ensure that all members contribute to the repository using branches, commits, and PRs.

2. Continuous Integration with GitHub Actions:
Implement continuous integration (CI) to automatically build, test, and verify the integrity of the code whenever changes are pushed to the repository. The CI setup must include:

* GitHub Actions Workflow: Set up a GitHub Actions workflow to automatically compile your C++ code and run unit tests upon each commit or pull request.
* Automated Testing: Write unit tests to validate your code. These tests should be run automatically as part of the CI pipeline. Aim for code coverage across important project components.
* Code Linting (Optional): Integrate static code analysis tools like cppcheck to ensure code quality, readability, and adherence to C++ best practices.

3. Containerization with Docker:
To ensure reproducibility and ease of use, a Docker image should be generated automatically from your project. This Docker setup must:

* Dockerfile: Write a Dockerfile that compiles the C++ code and includes any dependencies required to run the program.
* Automated Build: Use GitHub Actions to automate the creation of the Docker image on every successful CI pipeline run. The Docker image should be available in GitHub Packages or Docker Hub.
* Running the Project in Docker: The final Docker image should allow users to run your program with minimal setup, making it simple to execute and reproduce the project’s results.

4. Documentation:
Ensure that the repository is well-documented:

* README: Provide a README.md file that explains how to clone the repository, install dependencies, run the project, and build the Docker image.
* Contribution Guidelines: Include guidelines for contributing to the project, especially if it is a team project.
* Documentation for Code and Workflow: Clearly document the CI pipeline, testing strategy, and Docker setup. Consider adding links to relevant GitHub Actions, test reports, and Docker images.

This section integrates best practices from software engineering and DevOps, which are crucial for developing maintainable and reproducible scientific computing projects.

== Grading

The grading distribution is as follows:

[cols="l,2a,2a"]
|===
|Component |C++ Course |Project Course

|C++ Code Implementation |30% |-
|Mathematical Formulation and FEM |20% |5%
|Version Control | |5%
|CI with GitHub Actions | |10%
|Dockerization | |10%
|Code Documentation |10% |5%
|Report and Conclusion |20% |25%
|Oral Presentation | |25%
|===

== Appendices

=== Expression Evaluation

In the example_evaluator.cpp file provided, you'll find a small program that allows you to store and evaluate an expression (depending on x and y) in a class.
What's more, thanks to inheritance, only the base type can be used to pass expressions as parameters.
This principle can be extended to the evaluation of basic functions, for example.
This could be useful for numerical integration.


=== Solving a Sparse Linear System


In the example\_assembly.cpp file provided, you'll find a program that initializes a sparse matrix, eliminates a few rows from the matrix and solves the linear system.
The sparse matrix is constructed using the notion of a triplet, which will accumulate all the values to be added.
This triplet is represented by `(i,j,val)`, with `i` and `j` the indices of an entry in the matrix and val the value to be added.
An important point for the correct operation of the elimination method is the choice of sparse matrix type, which is made by specifying the template option `Eigen::RowMajor`.